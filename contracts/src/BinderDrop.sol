// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.20;

//
//                            &&&&&&&&&&&&&&&&&&&&
//                         &&&&&&&&&&&&&&&&&&&&&&&
//                       &&&&&&&&&&
//                      &&&&&&&
//                     &&&&&&&     &&&&&&&&&&&&&&&&&&&
//                     &&&&&&&    &&&&&&&&&&&&&&&&&&&&&&&
//                      &&&&&&      &&&&&&&&&&&&&&&&&&&&&&&
//                      &&&&&&&&                     &&&&&&&&
//                        &&&&&&&&&&&&&&&&&&&&&&&      &&&&&&
//                          &&&&&&&&&&&&&&&&&&&&&&*    &&&&&&&
//                             &&&&&&&&&&&&&&&&&&&     &&&&&&&
//                                                    &&&&&&&
//                                                &&&&&&&&&&
//                        &&&&&&   &&&&&&&&&&&&&&&&&&&&&&&
//                       &&&&&&   &&&&&&&&&&&&&&&&&&&&
//          Signed.gg (https://signed.gg), Powered by Binder (https://binder.studio)
//

import "openzeppelin-contracts/contracts/utils/cryptography/ECDSA.sol";
import "openzeppelin-contracts/contracts/proxy/utils/Initializable.sol";
import "openzeppelin-contracts/contracts/token/ERC721/ERC721.sol";
import "openzeppelin-contracts/contracts/access/Ownable.sol";
import "./Admins.sol";
import "./RecoverTokens.sol";

contract BinderDrop is ERC721, RecoverTokens {
    using Strings for uint256;
    uint256 public tokenCount = 0;
    mapping(bytes32 => bool) nonceMapping;
    bytes4 private constant ERC4906_INTERFACE_ID = bytes4(0x49064906);

    // mapping for tokenURIs
    mapping(uint256 tokenId => string) private _tokenURIs;

    // minter = sender of the mint transaction
    // orderId = client database id
    // recipient = parent token's TBA
    // tokenId = minted token id
    // hash = hash used to execute the mint (generated by the server)
    event AutographCreated(address minter, string orderId, address recipient, uint256 tokenId, bytes32 hash);
    event AutographBatchCreated(address minter, string[] orderIds, address[] recipients, uint256 tokenId, bytes32 hash);

    // erc4906
    event MetadataUpdate(uint256 _tokenId);

    constructor() ERC721("Signed.GG", "SIGNED") { }

    function supportsInterface(bytes4 interfaceId) public view override(ERC721) returns (bool) {
      return interfaceId == ERC4906_INTERFACE_ID || super.supportsInterface(interfaceId);
    }

    // soulbound
    function transferFrom(address from, address to, uint256 tokenId) public override (ERC721) {
      // tokens are only mintable, not transferrable
      require(from == address(0), "This a Soulbound token. It cannot be transferred. It can only be burned by the token owner.");
      super.transferFrom(from, to, tokenId);
    }

    function burn(uint256 tokenId) external {
      require(ownerOf(tokenId) == msg.sender, "Only the owner of the token can burn it.");
      _burn(tokenId);
    }

    function _verifyHash(bytes32 hash, bytes memory signature) internal view returns (bool) {
        return isAdmin(ECDSA.recover(hash, signature));
    }

    function mintTo(string memory orderId, address recipient, bytes memory signature, string memory uri, bytes32 nonce) public payable {
      require(nonceMapping[nonce] == false, "Nonce already used");

      bytes32 payloadhash = keccak256(abi.encode(recipient, nonce));
      bytes32 hash = keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", payloadhash));

      require(_verifyHash(hash, signature), "Hash verification failed");

      ++tokenCount;
      _safeMint(recipient, tokenCount);
      _setTokenURI(tokenCount, uri);
      nonceMapping[nonce] = true;

      emit AutographCreated(msg.sender, orderId, recipient, tokenCount, hash);
    }

    function mintToBatch(string[] memory orderIds, address[] memory recipients, bytes memory signature, string[] memory uris, bytes32 nonce) public payable {
      require(nonceMapping[nonce] == false, "Nonce already used");
      require(recipients.length == uris.length, "Recipient and URI arrays must have the same length");

      bytes32 payloadhash = keccak256(abi.encode(recipients, nonce));
      bytes32 hash = keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", payloadhash));

      require(_verifyHash(hash, signature), "Hash verification failed");
      nonceMapping[nonce] = true;

      uint256 firstTokenId = tokenCount + 1;
      tokenCount += uris.length;

      for (uint256 i; i < uris.length;) {
          uint256 tokenId = firstTokenId + i;
          _safeMint(recipients[i], tokenId);
          _setTokenURI(tokenId, uris[i]);
          unchecked {
              ++i;
          }
      }

      emit AutographBatchCreated(msg.sender, orderIds, recipients, tokenCount, hash);
    }


    // a minted token will always have uri set (we are passing URI in the mint function)
    function tokenURI(uint256 tokenId) public view override(ERC721) returns (string memory) {
      _requireOwned(tokenId);
      string memory _tokenURI = _tokenURIs[tokenId];
      return _tokenURI;
    }

    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {
      _tokenURIs[tokenId] = _tokenURI;
      emit MetadataUpdate(tokenId);
    }
}
